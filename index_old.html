<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Col-Bandit vs Full ColBERT - Side by Side Comparison</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            margin: 0;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            min-height: 100vh;
        }
        .mono { font-family: 'JetBrains Mono', monospace; }
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .gradient-text {
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .cell-pop {
            animation: cellPop 0.2s ease-out;
        }
        @keyframes cellPop {
            0% { transform: scale(0.5); }
            70% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .winner-glow {
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // =============================================================================
        // LOAD JSON FROM exp/ FOLDER
        // =============================================================================
        // 
        // Setup:
        // 1. Create folder: exp/
        // 2. Put your JSON files in exp/: exp/query1.json, exp/query2.json, etc.
        // 3. Create exp/index.json with list of files:
        //    ["query1.json", "query2.json", "query3.json"]
        //
        // Or run: python generate_manifest.py
        //
        // =============================================================================
        
        const EXP_FOLDER = 'exp';
        
        // Fetch the manifest and pick a random JSON file
        const fetchRandomDataset = async () => {
            try {
                // Load manifest
                const manifestRes = await fetch(`${EXP_FOLDER}/index.json`);
                if (!manifestRes.ok) {
                    console.log('No exp/index.json found, using embedded data or dummy');
                    return null;
                }
                
                const fileList = await manifestRes.json();
                if (!fileList || fileList.length === 0) {
                    console.log('Manifest is empty');
                    return null;
                }
                
                // Pick random file
                const randomFile = fileList[Math.floor(Math.random() * fileList.length)];
                console.log(`Loading: ${EXP_FOLDER}/${randomFile}`);
                
                // Fetch the JSON
                const dataRes = await fetch(`${EXP_FOLDER}/${randomFile}`);
                if (!dataRes.ok) {
                    console.error(`Failed to load ${randomFile}`);
                    return null;
                }
                
                const data = await dataRes.json();
                data._source_file = randomFile;
                return data;
            } catch (err) {
                console.error('Error loading dataset:', err);
                return null;
            }
        };
        
        // Get count of available datasets
        const fetchDatasetCount = async () => {
            try {
                const res = await fetch(`${EXP_FOLDER}/index.json`);
                if (!res.ok) return 0;
                const list = await res.json();
                return list.length;
            } catch {
                return 0;
            }
        };

        // =============================================================================
        // EMBEDDED JSON DATA (fallback if no exp/ folder)
        // =============================================================================
        const EMBEDDED_DATASETS = [
            // PASTE YOUR JSON DATA HERE AS FALLBACK
        ];
        
        const getRandomEmbeddedDataset = () => {
            if (EMBEDDED_DATASETS.length === 0) return null;
            const idx = Math.floor(Math.random() * EMBEDDED_DATASETS.length);
            return EMBEDDED_DATASETS[idx];
        };

        // =============================================================================
        // DATA GENERATION
        // =============================================================================
        
        const generateDummyData = (config = {}) => {
            const { N = 15, T = 10, K = 5, seed = 42 } = config;
            
            const seededRandom = (s) => {
                const x = Math.sin(s++) * 10000;
                return x - Math.floor(x);
            };
            let seedVal = seed;
            const random = () => seededRandom(seedVal++);
            
            const docNames = [
                "Climate Report", "AI Safety", "Quantum Computing", "Neural Networks",
                "Data Privacy", "Renewable Energy", "Space Exploration", "Genomics",
                "Economics", "Cybersecurity", "Machine Learning", "Cloud Computing",
                "Blockchain", "IoT Systems", "5G Networks", "Robotics", "Biotech",
                "Smart Cities", "AR/VR", "Edge Computing"
            ].slice(0, N);
            
            const queryTokens = ["what", "are", "the", "latest", "advances", "in", "AI", 
                                 "and", "ML", "research", "?", "help"].slice(0, T);
            
            const fullScores = [];
            for (let i = 0; i < N; i++) {
                const row = [];
                const baseScore = i < K ? 0.55 + random() * 0.4 : random() * 0.5;
                for (let t = 0; t < T; t++) {
                    row.push(Math.max(0.05, baseScore * (0.3 + random() * 0.7)));
                }
                fullScores.push(row);
            }
            
            // Shuffle
            const permutation = Array.from({length: N}, (_, i) => i);
            for (let i = N - 1; i > 0; i--) {
                const j = Math.floor(random() * (i + 1));
                [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
            }
            
            const shuffledScores = permutation.map(i => fullScores[i]);
            const shuffledNames = permutation.map(i => docNames[i]);
            
            const totalScores = shuffledScores.map((row, i) => ({
                docId: i,
                score: row.reduce((a, b) => a + b, 0)
            }));
            totalScores.sort((a, b) => b.score - a.score);
            const trueTopK = new Set(totalScores.slice(0, K).map(d => d.docId));
            const groundTruthOrder = totalScores.map(d => d.docId);
            
            return { N, T, K, docNames: shuffledNames, queryTokens, fullScores: shuffledScores, trueTopK, groundTruthOrder, totalScores };
        };

        // Load from JSON
        const loadFromJSON = (jsonData) => {
            try {
                const { N, T, K, full_scores, doc_names, query_tokens, reveals, decisions } = jsonData;
                
                console.log(`Loading JSON: N=${N}, T=${T}, K=${K}`);
                console.log(`Reveals: ${reveals ? reveals.length : 0}, Decisions: ${decisions ? decisions.length : 0}`);
                
                if (!full_scores || !N || !T || !K) {
                    throw new Error("Missing required fields: N, T, K, or full_scores");
                }
                
                const totalScores = full_scores.map((row, i) => ({
                    docId: i,
                    score: row.reduce((a, b) => a + b, 0)
                }));
                totalScores.sort((a, b) => b.score - a.score);
                const trueTopK = new Set(totalScores.slice(0, K).map(d => d.docId));
                const groundTruthOrder = totalScores.map(d => d.docId);
                
                // Convert pre-computed reveals/decisions from Python logger to history format
                let precomputedHistory = null;
                if (reveals && Array.isArray(reveals) && reveals.length > 0) {
                    precomputedHistory = convertPrecomputedToHistory(
                        N, T, K, full_scores, trueTopK, reveals, decisions, 
                        jsonData.bounds_history, jsonData.final_topk
                    );
                    console.log(`Precomputed history: ${precomputedHistory ? precomputedHistory.length + ' steps' : 'null'}`);
                }
                
                return {
                    N, T, K,
                    docNames: doc_names || Array.from({length: N}, (_, i) => `Doc ${i}`),
                    queryTokens: query_tokens || Array.from({length: T}, (_, t) => `t${t}`),
                    fullScores: full_scores,
                    trueTopK,
                    groundTruthOrder,
                    totalScores,
                    precomputedHistory
                };
            } catch (error) {
                console.error("Error loading JSON:", error);
                alert("Error loading JSON: " + error.message);
                return null;
            }
        };
        
        // Convert pre-computed reveals/decisions from Python logger to history format
        const convertPrecomputedToHistory = (N, T, K, fullScores, trueTopK, reveals, decisions, boundsHistory, finalTopK) => {
            console.log("=== Converting precomputed history ===");
            console.log("N:", N, "T:", T, "K:", K);
            console.log("Reveals count:", reveals ? reveals.length : 0);
            console.log("Decisions count:", decisions ? decisions.length : 0);
            console.log("Bounds history count:", boundsHistory ? boundsHistory.length : 0);
            console.log("Final TopK:", finalTopK);
            
            if (!reveals || reveals.length === 0) {
                console.error("No reveals data found");
                return null;
            }
            
            const history = [];
            const revealed = Array.from({length: N}, () => Array(T).fill(false));
            
            // Group reveals by step - reveals format: [step, docId, tokenId, value]
            const revealsByStep = {};
            for (let i = 0; i < reveals.length; i++) {
                const reveal = reveals[i];
                if (!reveal || reveal.length < 4) continue;
                const step = reveal[0];
                const docId = reveal[1];
                const tokenId = reveal[2];
                const value = reveal[3];
                
                if (!revealsByStep[step]) revealsByStep[step] = [];
                revealsByStep[step].push({ docId, tokenId, value });
            }
            
            console.log("Reveals by step:", Object.keys(revealsByStep).length, "unique steps");
            
            // Group bounds by step: [step, docId, LCB, UCB, S_hat]
            const boundsByStep = {};
            if (boundsHistory && boundsHistory.length > 0) {
                for (let i = 0; i < boundsHistory.length; i++) {
                    const b = boundsHistory[i];
                    if (!b || b.length < 5) continue;
                    const step = b[0];
                    const docId = b[1];
                    if (!boundsByStep[step]) boundsByStep[step] = {};
                    boundsByStep[step][docId] = {
                        lcb: b[2],
                        ucb: b[3],
                        estScore: b[4]
                    };
                }
                console.log("Bounds by step:", Object.keys(boundsByStep).length, "steps with bounds");
            }
            
            // Group decisions by step: [step, dK, b, lcbDK, ucbB, gap]
            const decisionsByStep = {};
            if (decisions && decisions.length > 0) {
                for (let i = 0; i < decisions.length; i++) {
                    const dec = decisions[i];
                    if (!dec || dec.length < 6) continue;
                    const step = dec[0];
                    decisionsByStep[step] = { 
                        dK: dec[1], 
                        b: dec[2], 
                        lcbDK: dec[3], 
                        ucbB: dec[4], 
                        gap: dec[5] 
                    };
                }
            }
            
            const stepKeys = Object.keys(revealsByStep).map(Number);
            if (stepKeys.length === 0) {
                console.error("No steps found in reveals");
                return null;
            }
            const maxStep = Math.max(...stepKeys);
            console.log("Max step:", maxStep);
            
            // Track partial sums for each doc
            const partialSum = Array(N).fill(0);
            const revealCount = Array(N).fill(0);
            
            for (let step = 0; step <= maxStep; step++) {
                // Apply reveals for this step
                if (revealsByStep[step]) {
                    revealsByStep[step].forEach(({ docId, tokenId, value }) => {
                        if (docId >= 0 && docId < N && tokenId >= 0 && tokenId < T) {
                            if (!revealed[docId][tokenId]) {
                                revealed[docId][tokenId] = true;
                                partialSum[docId] += value;
                                revealCount[docId]++;
                            }
                        }
                    });
                }
                
                // Build estimates - prefer bounds_history data if available
                const estimates = [];
                const stepBounds = boundsByStep[step];
                
                for (let docId = 0; docId < N; docId++) {
                    let estScore, lcb, ucb;
                    
                    if (stepBounds && stepBounds[docId]) {
                        // Use actual bounds from Python logger
                        estScore = stepBounds[docId].estScore;
                        lcb = stepBounds[docId].lcb;
                        ucb = stepBounds[docId].ucb;
                    } else {
                        // Fallback: compute from reveals
                        const count = revealCount[docId];
                        const sum = partialSum[docId];
                        const mu = count > 0 ? sum / count : 0;
                        estScore = T * mu;
                        const remaining = T - count;
                        lcb = sum;
                        ucb = sum + remaining;
                    }
                    
                    estimates.push({
                        docId, 
                        estScore, 
                        lcb, 
                        ucb, 
                        count: revealCount[docId],
                        partialSum: partialSum[docId],
                        isTrue: trueTopK.has(docId)
                    });
                }
                estimates.sort((a, b) => b.estScore - a.estScore);
                
                // Get decision info for this step
                const decision = decisionsByStep[step];
                let iPlus, iMinus, gap;
                
                if (decision) {
                    iPlus = estimates.find(e => e.docId === decision.dK);
                    iMinus = estimates.find(e => e.docId === decision.b);
                    gap = decision.gap;
                    if (iPlus) iPlus.lcb = decision.lcbDK;
                    if (iMinus) iMinus.ucb = decision.ucbB;
                } else {
                    const winners = estimates.slice(0, K);
                    const losers = estimates.slice(K);
                    iPlus = winners.length > 0 ? winners.reduce((min, d) => d.lcb < min.lcb ? d : min, winners[0]) : null;
                    iMinus = losers.length > 0 ? losers.reduce((max, d) => d.ucb > max.ucb ? d : max, losers[0]) : null;
                    gap = (iPlus && iMinus) ? iPlus.lcb - iMinus.ucb : -999;
                }
                
                // Get the last reveal for highlighting
                const stepReveals = revealsByStep[step];
                const lastReveal = stepReveals && stepReveals.length > 0 ? stepReveals[stepReveals.length - 1] : null;
                
                const isLastStep = step === maxStep;
                
                // For final step, reorder estimates to match final_topk if available
                let finalEstimates = estimates;
                if (isLastStep && finalTopK && finalTopK.length > 0) {
                    // Create a map for quick lookup
                    const estMap = {};
                    estimates.forEach(e => { estMap[e.docId] = e; });
                    
                    // Put finalTopK docs first in order
                    const topKEstimates = finalTopK.map(docId => estMap[docId]).filter(Boolean);
                    const otherEstimates = estimates.filter(e => !finalTopK.includes(e.docId));
                    otherEstimates.sort((a, b) => b.estScore - a.estScore);
                    finalEstimates = [...topKEstimates, ...otherEstimates];
                    
                    console.log("Final step - using final_topk order:", finalTopK);
                }
                
                history.push({
                    step,
                    docId: lastReveal ? lastReveal.docId : -1,
                    tokenId: lastReveal ? lastReveal.tokenId : -1,
                    revealed: revealed.map(row => [...row]),
                    estimates: finalEstimates,
                    currentTopK: finalEstimates.slice(0, K),
                    iPlus,
                    iMinus,
                    gap,
                    finished: gap >= 0 || isLastStep
                });
            }
            
            console.log("=== History conversion complete ===");
            console.log("Total history steps:", history.length);
            if (history.length > 0) {
                const last = history[history.length-1];
                console.log("Final step top-K:", last.currentTopK.map(e => e.docId));
            }
            return history;
        };

        // =============================================================================
        // SIMULATIONS
        // =============================================================================
        
        // Full ColBERT - exhaustive column by column
        const simulateFullColBERT = (data) => {
            const { N, T, fullScores, trueTopK, K } = data;
            const history = [];
            const revealed = Array.from({length: N}, () => Array(T).fill(false));
            let step = 0;
            
            for (let t = 0; t < T; t++) {
                for (let i = 0; i < N; i++) {
                    revealed[i][t] = true;
                    
                    const estimates = [];
                    for (let docId = 0; docId < N; docId++) {
                        let sum = 0, count = 0;
                        for (let tt = 0; tt < T; tt++) {
                            if (revealed[docId][tt]) {
                                sum += fullScores[docId][tt];
                                count++;
                            }
                        }
                        estimates.push({ docId, estScore: sum, count, isTrue: trueTopK.has(docId) });
                    }
                    estimates.sort((a, b) => b.estScore - a.estScore);
                    
                    history.push({
                        step, docId: i, tokenId: t,
                        revealed: revealed.map(row => [...row]),
                        estimates,
                        currentTopK: estimates.slice(0, K),
                        finished: t === T - 1 && i === N - 1
                    });
                    step++;
                }
            }
            return history;
        };

        // Col-Bandit adaptive
        const simulateColBandit = (data, config = {}) => {
            const { alpha_ef = 0.4, epsilon = 0.1, delta = 0.01 } = config;
            const { N, T, K, fullScores, trueTopK } = data;
            
            const revealed = Array.from({length: N}, () => Array(T).fill(false));
            const n = Array(N).fill(0);
            const partialSum = Array(N).fill(0);
            const partialSqSum = Array(N).fill(0);
            
            const history = [];
            let step = 0;
            
            const computeState = () => {
                const estimates = [];
                for (let i = 0; i < N; i++) {
                    let lcb, ucb, estScore;
                    if (n[i] > 0) {
                        const mu = partialSum[i] / n[i];
                        estScore = T * mu;
                        const variance = n[i] > 1 ? (partialSqSum[i] / n[i]) - mu * mu : 0.25;
                        const sigma = Math.sqrt(Math.max(0, variance));
                        const rho = n[i] <= T/2 ? 1 - (n[i] - 1) / T : (1 - n[i]/T) * (1 + 1/n[i]);
                        const r_eff = alpha_ef * T * sigma * Math.sqrt(2 * Math.log(N / delta) / n[i]) * Math.sqrt(Math.max(0, rho));
                        const remaining = T - n[i];
                        lcb = Math.max(partialSum[i], estScore - r_eff);
                        ucb = Math.min(partialSum[i] + remaining, estScore + r_eff);
                    } else {
                        estScore = 0; lcb = 0; ucb = T;
                    }
                    estimates.push({ docId: i, estScore, lcb, ucb, count: n[i], isTrue: trueTopK.has(i) });
                }
                estimates.sort((a, b) => b.estScore - a.estScore);
                
                const currentTopK = estimates.slice(0, K);
                const outside = estimates.slice(K);
                const iPlus = currentTopK.reduce((min, d) => d.lcb < min.lcb ? d : min, currentTopK[0]);
                const iMinus = outside.length > 0 ? outside.reduce((max, d) => d.ucb > max.ucb ? d : max, outside[0]) : null;
                const gap = iMinus ? iPlus.lcb - iMinus.ucb : Infinity;
                
                return { estimates, currentTopK, iPlus, iMinus, gap };
            };
            
            // Initialize: 1 cell per doc
            for (let i = 0; i < N; i++) {
                const t = Math.floor(Math.random() * T);
                revealed[i][t] = true;
                n[i]++;
                partialSum[i] += fullScores[i][t];
                partialSqSum[i] += fullScores[i][t] ** 2;
            }
            
            let state = computeState();
            history.push({
                step, docId: -1, tokenId: -1,
                revealed: revealed.map(row => [...row]),
                ...state, finished: false
            });
            step++;
            
            // Main loop
            while (step < N * T) {
                state = computeState();
                
                if (state.gap >= 0) {
                    history.push({
                        step, docId: -1, tokenId: -1,
                        revealed: revealed.map(row => [...row]),
                        ...state, finished: true
                    });
                    break;
                }
                
                const { iPlus, iMinus } = state;
                let iStar = (iPlus.ucb - iPlus.lcb) >= (iMinus.ucb - iMinus.lcb) ? iPlus.docId : iMinus.docId;
                
                let unrevealed = [];
                for (let t = 0; t < T; t++) {
                    if (!revealed[iStar][t]) unrevealed.push(t);
                }
                
                if (unrevealed.length === 0) {
                    const altDoc = iStar === iPlus.docId ? iMinus.docId : iPlus.docId;
                    for (let t = 0; t < T; t++) {
                        if (!revealed[altDoc][t]) unrevealed.push(t);
                    }
                    if (unrevealed.length > 0) iStar = altDoc;
                }
                
                if (unrevealed.length === 0) break;
                
                const tStar = Math.random() < epsilon
                    ? unrevealed[Math.floor(Math.random() * unrevealed.length)]
                    : unrevealed[0];
                
                revealed[iStar][tStar] = true;
                n[iStar]++;
                partialSum[iStar] += fullScores[iStar][tStar];
                partialSqSum[iStar] += fullScores[iStar][tStar] ** 2;
                
                state = computeState();
                history.push({
                    step, docId: iStar, tokenId: tStar,
                    revealed: revealed.map(row => [...row]),
                    ...state, finished: false
                });
                step++;
            }
            
            return history;
        };

        // =============================================================================
        // COMPONENTS
        // =============================================================================
        
        // Density Chart - shows reveal % per document, sorted by score
        const DensityChart = ({ data, revealed, mode, finished, estimates }) => {
            const { fullScores, trueTopK, K, T, N } = data;
            
            if (!revealed || !fullScores) {
                return (
                    <div className="glass rounded-xl p-3">
                        <div className="text-gray-500 text-center text-sm">Loading...</div>
                    </div>
                );
            }
            
            const totalCells = N * T;
            let revealedCells = 0;
            
            const isColBandit = mode === 'colbandit';
            const borderColor = finished ? (isColBandit ? 'border-green-500 winner-glow' : 'border-gray-500') : 'border-gray-700';
            
            // Sort documents by estimated score
            let sortedDocs;
            if (estimates && estimates.length > 0) {
                sortedDocs = estimates.map(e => e.docId);
            } else {
                const scores = fullScores.map((row, i) => ({ docId: i, score: row.reduce((a, b) => a + b, 0) }));
                scores.sort((a, b) => b.score - a.score);
                sortedDocs = scores.map(s => s.docId);
            }
            
            // Compute reveal count per doc
            const docData = sortedDocs.map((docId, rank) => {
                let count = 0;
                for (let t = 0; t < T; t++) {
                    if (revealed[docId] && revealed[docId][t]) count++;
                }
                revealedCells += count;
                return { 
                    docId, 
                    rank,
                    count, 
                    pct: (count / T) * 100,
                    isTrue: trueTopK.has(docId),
                    isTopK: rank < K
                };
            });
            
            const coverage = (revealedCells / totalCells * 100).toFixed(0);
            
            // Stats
            const topKData = docData.filter(d => d.isTopK);
            const otherData = docData.filter(d => !d.isTopK);
            const avgTopK = topKData.length > 0 ? (topKData.reduce((s, d) => s + d.pct, 0) / topKData.length).toFixed(0) : 0;
            const avgOther = otherData.length > 0 ? (otherData.reduce((s, d) => s + d.pct, 0) / otherData.length).toFixed(0) : 0;
            
            // Bar height calculation
            const maxHeight = 200;
            const barHeight = Math.max(2, Math.min(8, Math.floor(maxHeight / N)));
            
            return (
                <div className={`glass rounded-xl p-3 border-2 ${borderColor} transition-all duration-300`}>
                    <div className="flex justify-between items-center mb-2">
                        <h3 className={`font-bold ${isColBandit ? 'text-green-400' : 'text-red-400'}`}>
                            {isColBandit ? 'üü¢ Col-Bandit' : 'üî¥ Full ColBERT'}
                            <span className="text-gray-500 font-normal text-sm ml-2">
                                ({coverage}% coverage)
                            </span>
                        </h3>
                    </div>
                    
                    {/* Density bars */}
                    <div className="flex gap-2">
                        {/* Doc labels */}
                        <div className="flex flex-col text-xs text-gray-500 justify-between" style={{ width: 50, height: barHeight * N }}>
                            <span>Rank 1</span>
                            <span className="text-yellow-400">Top-{K} ‚îÄ</span>
                            <span className="text-gray-600">Rank {N}</span>
                        </div>
                        
                        {/* Bars */}
                        <div className="flex-1">
                            <div 
                                className="bg-gray-900 rounded overflow-hidden relative"
                                style={{ height: barHeight * N }}
                            >
                                {docData.map((doc, idx) => {
                                    const barColor = isColBandit
                                        ? (doc.isTrue ? 'bg-green-500' : 'bg-green-700')
                                        : (doc.isTrue ? 'bg-red-400' : 'bg-red-600');
                                    
                                    return (
                                        <div 
                                            key={doc.docId}
                                            className="flex items-center"
                                            style={{ height: barHeight }}
                                        >
                                            <div 
                                                className={`h-full ${barColor}`}
                                                style={{ width: `${doc.pct}%`, minWidth: doc.pct > 0 ? 1 : 0 }}
                                            />
                                        </div>
                                    );
                                })}
                                
                                {/* Top-K separator */}
                                <div 
                                    className="absolute left-0 right-0 border-t-2 border-yellow-500 pointer-events-none"
                                    style={{ top: barHeight * K }}
                                />
                            </div>
                            
                            {/* X-axis */}
                            <div className="flex justify-between text-xs text-gray-500 mt-1">
                                <span>0%</span>
                                <span>Tokens Revealed ‚Üí</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                    
                    {/* Summary */}
                    <div className="mt-3 grid grid-cols-2 gap-2 text-sm">
                        <div className={`rounded p-2 text-center ${isColBandit ? 'bg-green-900/30' : 'bg-red-900/30'}`}>
                            <div className={`font-bold text-lg ${isColBandit ? 'text-green-400' : 'text-red-400'}`}>
                                {avgTopK}%
                            </div>
                            <div className="text-gray-400 text-xs">Avg Top-{K} density</div>
                        </div>
                        <div className={`rounded p-2 text-center ${isColBandit ? 'bg-green-900/30' : 'bg-red-900/30'}`}>
                            <div className={`font-bold text-lg ${isColBandit ? 'text-green-400' : 'text-red-400'}`}>
                                {avgOther}%
                            </div>
                            <div className="text-gray-400 text-xs">Avg others density</div>
                        </div>
                    </div>
                </div>
            );
        };

        // Rankings
        const Rankings = ({ data, estimates, mode, iPlus, iMinus, gap }) => {
            const { K, trueTopK } = data;
            if (!estimates || estimates.length === 0) {
                return (
                    <div className="glass rounded-xl p-3">
                        <div className="text-gray-500 text-center text-sm">Loading rankings...</div>
                    </div>
                );
            }
            
            const isColBandit = mode === 'colbandit';
            const headerColor = isColBandit ? 'text-green-400' : 'text-red-400';
            
            // Sort appropriately
            let displayDocs;
            if (isColBandit) {
                const winners = estimates.slice(0, K).sort((a, b) => b.lcb - a.lcb);
                const losers = estimates.slice(K, K + 3).sort((a, b) => b.ucb - a.ucb);
                displayDocs = [...winners, ...losers];
            } else {
                displayDocs = estimates.slice(0, K + 3);
            }
            
            const maxScore = Math.max(...displayDocs.map(d => d.ucb || d.estScore || 1), 1);
            
            return (
                <div className="glass rounded-xl p-3">
                    <div className="flex justify-between items-center mb-2">
                        <h4 className={`font-bold text-sm ${headerColor}`}>Rankings</h4>
                        {isColBandit && gap !== undefined && (
                            <span className={`text-xs px-2 py-0.5 rounded mono ${gap >= 0 ? 'bg-green-900 text-green-300' : 'bg-gray-700 text-gray-300'}`}>
                                Gap: {gap.toFixed(2)} {gap >= 0 ? '‚úì' : ''}
                            </span>
                        )}
                    </div>
                    
                    <div className="space-y-1">
                        {displayDocs.map((doc, idx) => {
                            const isTrue = trueTopK.has(doc.docId);
                            const isWinner = idx < K;
                            const isIPlusDoc = isColBandit && doc.docId === iPlus?.docId;
                            const isIMinusDoc = isColBandit && doc.docId === iMinus?.docId;
                            
                            const estWidth = Math.max(5, ((doc.estScore || 0) / maxScore) * 100);
                            const lcbWidth = isColBandit ? Math.max(2, ((doc.lcb || 0) / maxScore) * 100) : estWidth;
                            const ucbWidth = isColBandit ? Math.min(100, ((doc.ucb || doc.estScore) / maxScore) * 100) : estWidth;
                            
                            return (
                                <div key={doc.docId}>
                                    {idx === K && <div className="border-t border-yellow-500/50 my-1"></div>}
                                    <div className={`flex items-center gap-1 py-0.5 px-1 rounded ${(isIPlusDoc || isIMinusDoc) ? 'bg-blue-900/30' : ''}`}>
                                        <span className={`w-4 text-xs ${isWinner ? 'text-yellow-400 font-bold' : 'text-gray-600'}`}>
                                            {idx + 1}
                                        </span>
                                        <span className={`w-6 text-xs font-bold ${isTrue ? 'text-green-400' : 'text-red-400'}`}>
                                            D{doc.docId}
                                        </span>
                                        
                                        <div className="flex-1 h-4 bg-gray-700 rounded relative overflow-hidden">
                                            {/* UCB background */}
                                            {isColBandit && (
                                                <div 
                                                    className="absolute h-full bg-gray-600/60 transition-all" 
                                                    style={{ width: `${ucbWidth}%` }} 
                                                />
                                            )}
                                            {/* Est score bar */}
                                            <div 
                                                className={`absolute h-full transition-all ${isTrue ? 'bg-green-500' : 'bg-red-500'}`}
                                                style={{ width: `${estWidth}%`, opacity: 0.7 }}
                                            />
                                            {/* LCB line */}
                                            {isColBandit && (
                                                <div 
                                                    className="absolute h-full w-0.5 bg-white transition-all" 
                                                    style={{ left: `${lcbWidth}%` }} 
                                                />
                                            )}
                                        </div>
                                        
                                        <span className="w-6 text-xs text-gray-500 mono text-right">
                                            {doc.count || 0}
                                        </span>
                                        
                                        {isIPlusDoc && <span className="text-blue-400 text-xs font-bold w-4">i‚Å∫</span>}
                                        {isIMinusDoc && <span className="text-orange-400 text-xs font-bold w-4">i‚Åª</span>}
                                        {!isIPlusDoc && !isIMinusDoc && <span className="w-4"></span>}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // Stats
        const Stats = ({ colbertCells, colbanditState, data }) => {
            const { N, T, K, trueTopK } = data;
            const totalCells = N * T;
            
            // Safely count revealed cells
            const countRevealed = (revealed) => {
                if (!revealed || !Array.isArray(revealed)) return 0;
                let count = 0;
                for (let d = 0; d < revealed.length; d++) {
                    if (revealed[d]) {
                        for (let t = 0; t < revealed[d].length; t++) {
                            if (revealed[d][t]) count++;
                        }
                    }
                }
                return count;
            };
            
            const colbanditCells = countRevealed(colbanditState?.revealed);
            
            const colbanditFinished = colbanditState?.finished;
            const savings = colbanditFinished ? ((1 - colbanditCells / totalCells) * 100).toFixed(0) : '‚Äî';
            const speedup = colbanditFinished && colbanditCells > 0 ? (totalCells / colbanditCells).toFixed(1) : '‚Äî';
            
            // Calculate recall for colbandit
            let recall = '‚Äî';
            if (colbanditFinished && colbanditState?.currentTopK) {
                const foundTopK = new Set(colbanditState.currentTopK.map(e => e.docId));
                const correct = [...trueTopK].filter(d => foundTopK.has(d)).length;
                recall = ((correct / K) * 100).toFixed(0);
            }
            
            return (
                <div className="grid grid-cols-5 gap-2 mb-4">
                    <div className="glass rounded-lg p-2 text-center">
                        <div className="text-xl font-bold text-red-400">{colbertCells}</div>
                        <div className="text-xs text-gray-400">ColBERT</div>
                    </div>
                    <div className="glass rounded-lg p-2 text-center">
                        <div className="text-xl font-bold text-green-400">{colbanditCells}</div>
                        <div className="text-xs text-gray-400">Col-Bandit</div>
                    </div>
                    <div className="glass rounded-lg p-2 text-center">
                        <div className={`text-xl font-bold ${colbanditFinished ? 'text-blue-400' : 'text-gray-500'}`}>{savings}%</div>
                        <div className="text-xs text-gray-400">Savings</div>
                    </div>
                    <div className="glass rounded-lg p-2 text-center">
                        <div className={`text-xl font-bold ${colbanditFinished ? 'text-purple-400' : 'text-gray-500'}`}>{speedup}√ó</div>
                        <div className="text-xs text-gray-400">Speedup</div>
                    </div>
                    <div className="glass rounded-lg p-2 text-center">
                        <div className={`text-xl font-bold ${recall === '100' ? 'text-green-400' : recall === '‚Äî' ? 'text-gray-500' : 'text-yellow-400'}`}>{recall}%</div>
                        <div className="text-xs text-gray-400">Recall@{K}</div>
                    </div>
                </div>
            );
        };

        // Progress - only shows ColBandit since ColBERT is static
        const Progress = ({ colbanditStep, colbanditMax, colbanditFinished }) => (
            <div className="glass rounded-lg p-3 mb-4">
                <div className="flex justify-between text-xs mb-1">
                    <span className="text-green-400">Col-Bandit Progress {colbanditFinished ? '‚úì' : ''}</span>
                    <span className="text-gray-500">Step {colbanditStep} / {colbanditMax || '?'}</span>
                </div>
                <div className="h-2 bg-gray-700 rounded overflow-hidden">
                    <div 
                        className={`h-full transition-all ${colbanditFinished ? 'bg-green-500' : 'bg-green-600'}`} 
                        style={{ width: colbanditMax > 0 ? `${(colbanditStep / colbanditMax) * 100}%` : '0%' }} 
                    />
                </div>
            </div>
        );

        // Controls
        const Controls = ({ isPlaying, setIsPlaying, onReset, onEnd, speed, setSpeed, onRegenerate, datasetCount }) => {
            return (
                <div className="glass rounded-xl p-3 mb-4 flex flex-wrap items-center gap-2">
                    <button
                        onClick={() => setIsPlaying(!isPlaying)}
                        className={`px-5 py-2 rounded-lg font-bold transition ${
                            isPlaying ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'
                        } text-white`}
                    >
                        {isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play'}
                    </button>
                    <button onClick={onReset} className="px-3 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-white text-sm">‚èÆ Reset</button>
                    <button onClick={onEnd} className="px-3 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-white text-sm">‚è≠ End</button>
                    
                    <div className="flex items-center gap-1">
                        <span className="text-xs text-gray-400">Speed:</span>
                        <input type="range" min="1" max="50" value={speed} onChange={(e) => setSpeed(parseInt(e.target.value))} className="w-20" />
                    </div>
                    
                    <div className="flex-1"></div>
                    
                    <button onClick={onRegenerate} className="px-3 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-white text-sm">
                        üé≤ New {datasetCount > 0 && <span className="text-purple-300">({datasetCount})</span>}
                    </button>
                </div>
            );
        };

        // Intro
        const Intro = ({ isLoaded }) => (
            <div className="glass rounded-xl p-3 mb-4">
                {isLoaded && (
                    <div className="bg-blue-900/30 border border-blue-500/50 rounded-lg p-2 mb-3 text-center">
                        <span className="text-blue-400 text-sm">üìÅ Loaded from file - replaying actual Col-Bandit execution</span>
                    </div>
                )}
                <div className="grid md:grid-cols-3 gap-3 text-xs">
                    <div className="bg-red-900/20 rounded p-2">
                        <span className="text-red-400 font-bold">üî¥ ColBERT:</span>
                        <span className="text-gray-400 ml-1">Computes ALL N√óT cells exhaustively</span>
                    </div>
                    <div className="bg-green-900/20 rounded p-2">
                        <span className="text-green-400 font-bold">üü¢ Col-Bandit:</span>
                        <span className="text-gray-400 ml-1">Adaptively reveals cells until Top-K separated</span>
                    </div>
                    <div className="bg-blue-900/20 rounded p-2">
                        <span className="text-blue-400 font-bold">üí° Result:</span>
                        <span className="text-gray-400 ml-1">Same ranking, ~70-80% less computation!</span>
                    </div>
                </div>
            </div>
        );

        // Legend
        const Legend = ({ K }) => (
            <div className="flex flex-wrap gap-3 text-xs text-gray-400 justify-center mb-4">
                <span><span className="inline-block w-3 h-3 bg-red-500 rounded mr-1"></span>ColBERT</span>
                <span><span className="inline-block w-3 h-3 bg-green-500 rounded mr-1"></span>Col-Bandit</span>
                <span><span className="text-green-400">‚úì</span> True Top-{K}</span>
                <span><span className="text-blue-400">i‚Å∫</span> Weakest winner</span>
                <span><span className="text-orange-400">i‚Åª</span> Strongest loser</span>
                <span><span className="text-yellow-400">‚Äî</span> Top-{K} boundary</span>
            </div>
        );

        // Data Loader
        const DataLoader = ({ onLoad, onClose }) => {
            const [jsonText, setJsonText] = useState('');
            
            const handleLoad = () => {
                try {
                    onLoad(JSON.parse(jsonText));
                    onClose();
                } catch (e) {
                    alert('Invalid JSON: ' + e.message);
                }
            };
            
            return (
                <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                    <div className="glass rounded-xl p-4 max-w-lg w-full">
                        <h2 className="text-lg font-bold text-white mb-3">Load Data</h2>
                        <input type="file" accept=".json" onChange={(e) => {
                            const file = e.target.files[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (e) => setJsonText(e.target.result);
                                reader.readAsText(file);
                            }
                        }} className="mb-3 text-gray-400 text-sm" />
                        <textarea
                            value={jsonText}
                            onChange={(e) => setJsonText(e.target.value)}
                            className="w-full h-32 bg-gray-800 text-gray-300 rounded p-2 mono text-xs mb-3"
                            placeholder="Paste JSON..."
                        />
                        <div className="flex gap-2 justify-end">
                            <button onClick={onClose} className="px-3 py-1 bg-gray-600 rounded text-white text-sm">Cancel</button>
                            <button onClick={handleLoad} className="px-3 py-1 bg-blue-600 rounded text-white text-sm">Load</button>
                        </div>
                    </div>
                </div>
            );
        };

        // =============================================================================
        // MAIN APP
        // =============================================================================
        
        const App = () => {
            const [data, setData] = useState(() => generateDummyData({ N: 12, T: 8, K: 4, seed: 123 }));
            const [showLoader, setShowLoader] = useState(false);
            const [datasetCount, setDatasetCount] = useState(0);
            
            // Load initial dataset from exp/ folder
            useEffect(() => {
                const loadInitial = async () => {
                    // Try exp/ folder first
                    const fetched = await fetchRandomDataset();
                    if (fetched) {
                        const loaded = loadFromJSON(fetched);
                        if (loaded) {
                            setData(loaded);
                            return;
                        }
                    }
                    // Fallback to embedded
                    const embedded = getRandomEmbeddedDataset();
                    if (embedded) {
                        const loaded = loadFromJSON(embedded);
                        if (loaded) setData(loaded);
                    }
                };
                loadInitial();
                
                // Get count for UI
                fetchDatasetCount().then(setDatasetCount);
            }, []);
            
            const [colbertHistory, setColbertHistory] = useState([]);
            const [colbanditHistory, setColbanditHistory] = useState([]);
            
            const [colbertStep, setColbertStep] = useState(0);
            const [colbanditStep, setColbanditStep] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [speed, setSpeed] = useState(15);
            
            // Generate histories
            useEffect(() => {
                console.log("Generating histories for data:", data.N, "x", data.T);
                
                const colbert = simulateFullColBERT(data);
                console.log("ColBERT history generated:", colbert.length, "steps");
                setColbertHistory(colbert);
                
                // Use precomputed history if available, otherwise simulate
                if (data.precomputedHistory && data.precomputedHistory.length > 0) {
                    console.log("Using precomputed history:", data.precomputedHistory.length, "steps");
                    setColbanditHistory(data.precomputedHistory);
                } else {
                    console.log("Simulating ColBandit...");
                    const colbandit = simulateColBandit(data);
                    console.log("ColBandit history generated:", colbandit.length, "steps");
                    setColbanditHistory(colbandit);
                }
                
                setColbertStep(0);
                setColbanditStep(0);
            }, [data]);
            
            const colbertMax = colbertHistory.length > 0 ? colbertHistory.length - 1 : 0;
            const colbanditMax = colbanditHistory.length > 0 ? colbanditHistory.length - 1 : 0;
            
            const colbertState = colbertHistory[colbertStep] || { 
                revealed: Array.from({length: data.N}, () => Array(data.T).fill(false)), 
                estimates: [],
                finished: false
            };
            const colbanditState = colbanditHistory[colbanditStep] || { 
                revealed: Array.from({length: data.N}, () => Array(data.T).fill(false)), 
                estimates: [],
                finished: false,
                iPlus: null,
                iMinus: null,
                gap: -999
            };
            
            // Static ColBERT - always 100% revealed
            const colbertFullRevealed = useMemo(() => 
                Array.from({length: data.N}, () => Array(data.T).fill(true)), 
                [data.N, data.T]
            );
            
            // ColBERT final estimates - computed from full scores
            const colbertFinalEstimates = useMemo(() => {
                const estimates = data.fullScores.map((scores, docId) => ({
                    docId,
                    estScore: scores.reduce((a, b) => a + b, 0),
                    count: data.T,
                    isTrue: data.trueTopK.has(docId)
                }));
                estimates.sort((a, b) => b.estScore - a.estScore);
                return estimates;
            }, [data]);
            
            const colbanditFinished = colbanditState?.finished || false;
            
            // Debug logging
            useEffect(() => {
                console.log("ColBERT history length:", colbertHistory.length);
                console.log("ColBandit history length:", colbanditHistory.length);
                console.log("Has precomputed:", !!data.precomputedHistory);
            }, [colbertHistory, colbanditHistory, data]);
            
            // Animation - only ColBandit (ColBERT is static)
            useEffect(() => {
                if (!isPlaying) return;
                if (colbanditHistory.length === 0) {
                    console.log("Waiting for ColBandit history to load...");
                    return;
                }
                
                if (colbanditStep >= colbanditMax) {
                    setIsPlaying(false);
                    return;
                }
                
                const interval = setInterval(() => {
                    setColbanditStep(prev => Math.min(prev + 1, colbanditMax));
                }, 200 / speed);
                
                return () => clearInterval(interval);
            }, [isPlaying, colbanditStep, colbanditMax, speed, colbanditHistory.length]);
            
            return (
                <div className="min-h-screen p-3">
                    <div className="max-w-5xl mx-auto">
                        {/* Header */}
                        <header className="text-center mb-4">
                            <h1 className="text-2xl font-bold">
                                <span className="gradient-text">Col-Bandit</span>
                                <span className="text-gray-400 text-lg ml-2">vs Full ColBERT</span>
                            </h1>
                        </header>
                        
                        <Intro isLoaded={!!data.precomputedHistory} />
                        
                        <Controls
                            isPlaying={isPlaying}
                            setIsPlaying={setIsPlaying}
                            onReset={() => { setColbanditStep(0); setIsPlaying(false); }}
                            onEnd={() => { setColbanditStep(colbanditMax); setIsPlaying(false); }}
                            speed={speed}
                            setSpeed={setSpeed}
                            datasetCount={datasetCount}
                            onRegenerate={async () => {
                                // Try exp/ folder first
                                const fetched = await fetchRandomDataset();
                                if (fetched) {
                                    const loaded = loadFromJSON(fetched);
                                    if (loaded) {
                                        setData(loaded);
                                        setColbanditStep(0);
                                        setIsPlaying(false);
                                        return;
                                    }
                                }
                                // Fallback to embedded
                                const embedded = getRandomEmbeddedDataset();
                                if (embedded) {
                                    const loaded = loadFromJSON(embedded);
                                    if (loaded) {
                                        setData(loaded);
                                        setColbanditStep(0);
                                        setIsPlaying(false);
                                        return;
                                    }
                                }
                                // Fallback to dummy
                                setData(generateDummyData({ N: 12, T: 8, K: 4, seed: Math.floor(Math.random() * 10000) }));
                                setColbanditStep(0);
                                setIsPlaying(false);
                            }}
                        />
                        
                        <Stats 
                            colbertCells={data.N * data.T} 
                            colbanditState={colbanditState} 
                            data={data} 
                        />
                        
                        <Progress 
                            colbanditStep={colbanditStep} 
                            colbanditMax={colbanditMax}
                            colbanditFinished={colbanditFinished}
                        />
                        
                        <Legend K={data.K} />
                        
                        {/* Query Display */}
                        {data.queryTokens && (
                            <div className="glass rounded-lg p-3 mb-4">
                                <div className="text-xs text-gray-400 mb-1">Query ({data.T} tokens):</div>
                                <div className="flex flex-wrap gap-1">
                                    {data.queryTokens.slice(0, 20).map((token, i) => (
                                        <span key={i} className="px-2 py-0.5 bg-blue-900/50 text-blue-300 rounded text-sm">
                                            {token}
                                        </span>
                                    ))}
                                    {data.T > 20 && <span className="text-gray-500 text-sm">... +{data.T - 20} more</span>}
                                </div>
                            </div>
                        )}
                        
                        {/* Side by Side */}
                        <div className="grid md:grid-cols-2 gap-4">
                            {/* ColBERT - Static, always 100% */}
                            <div className="space-y-3">
                                <Rankings
                                    data={data}
                                    estimates={colbertFinalEstimates}
                                    mode="colbert"
                                />
                                <DensityChart
                                    data={data}
                                    revealed={colbertFullRevealed}
                                    mode="colbert"
                                    finished={true}
                                    estimates={colbertFinalEstimates}
                                />
                            </div>
                            
                            {/* Col-Bandit - Animated */}
                            <div className="space-y-3">
                                <Rankings
                                    data={data}
                                    estimates={colbanditState?.estimates}
                                    mode="colbandit"
                                    iPlus={colbanditState?.iPlus}
                                    iMinus={colbanditState?.iMinus}
                                    gap={colbanditState?.gap}
                                />
                                <DensityChart
                                    data={data}
                                    revealed={colbanditState?.revealed || Array.from({length: data.N}, () => Array(data.T).fill(false))}
                                    mode="colbandit"
                                    finished={colbanditState?.finished}
                                    estimates={colbanditState?.estimates}
                                />
                            </div>
                        </div>
                        
                        {/* Load Button */}
                        <div className="mt-4 text-center">
                            <button onClick={() => setShowLoader(true)} className="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-white text-sm">
                                üìÅ Load JSON Data
                            </button>
                        </div>
                        
                        <footer className="text-center text-gray-600 text-xs mt-4">
                            Col-Bandit: Zero-Shot Query-Time Pruning for Late-Interaction Retrieval
                        </footer>
                    </div>
                    
                    {showLoader && <DataLoader onLoad={(d) => {
                        const loaded = loadFromJSON(d);
                        if (loaded) setData(loaded);
                    }} onClose={() => setShowLoader(false)} />}
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
